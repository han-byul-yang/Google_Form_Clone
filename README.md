# :pushpin: Google Form Clone

## 1. 배포 사이트
https://googleformclone1.netlify.app

## 2. 제작 기간 & 참여 인원
- 2023.2.28 - 2023.3.8 (+리팩토링)
- 개인 프로젝트
 
## 3. 사용 기술 및 라이브러리
- react v18
- typescript
- **라우팅**
  - react-router-dom v6
- **스타일**
   - scss
   - css module
- **상태 관리**
   - react-redux(@reduxjs/toolkit)
- **코딩 컨벤션**
   - eslint
   - prettier
   - stylelint

## 4. 주요 구현 기능
### 4.1. 주요 기능
- [x] 설문지 제목 추가 및 편집
- [x] 설문지 설명 추가 및 편집
- [x] 질문 옵션 선택
  - 단답형
  - 장문형
  - 객관식 질문
  - 체크박스
  - 드롭다운
- [x] 질문 옵션 질문 추가(+기타)
- [x] 질문 폼 추가 기능
- [x] 질문 폼 복사 기능
- [x] 질문 폼 삭제 기능
- [x] 필수 옵션 설정 기능
- [x] 설문지 미리보기
- [x] 제출 클릭 시 사용자 입력 정보 보기
- [x] 양식 지우기

### 4.2. `사용성을 고려`한 기타 상세 구현 사항
- 폼 클릭 시 활성화 된 폼 표시
- 폼 추가 및 복사 클릭 시 활성화 된 폼 뒤에 추가
- 필수 항목일 경우 값 미입력 시 오류 표시
- 제출 버튼 클릭 시 필수 항목 미입력 있으면 미입력 폼으로 스크롤 이동

![image](https://github.com/han-byul-yang/Google_Form_Clone/assets/67466789/6bd38b3e-b8a0-4ecd-b462-56bc18493ad6)
![image](https://github.com/han-byul-yang/Google_Form_Clone/assets/67466789/cbb7e95a-2ce8-449f-a36f-00dd17a90ec2)
![image](https://github.com/han-byul-yang/Google_Form_Clone/assets/67466789/72e1fddb-d6c4-439a-a0d0-0b85d3c265df)


## 5. 구현하면서 고민 및 고려한 점
### 5.1. 디자인 패턴에 대한 고민 [참고 자료](https://yozm.wishket.com/magazine/detail/1531)
디자인 구조는 여러가지가 알려져 있다. 특히 프론트엔드에서는 이 디자인 구조를 따르기 위한 설계가 아니라 좋은 컴포넌트를 설계하기 위해 구조를 유연하게 맞게 사용하는 것이 좋은 방향이라고 생각한다.

처음엔 atomic pattern을 고려하였다. Atomic pattern을 사용하려고 한 이유는 계층별 추상화된 컴포넌트를 나누게 되면 재상용성이 높아질 것으로 기대했기 때문이다. 하지만 실제로 개발 시 **해당 컴포넌트가 어느 계층 위치에 있는지 계속해서 확인해야하는 인지과정 비용**이 생각보다 많이 발생한다는 것을 느꼈다. 이에 재사용성을 높이기 위한 방법으로 다른 방식을 선택하되 **직관성 및 협업에 도움이 되는 구조**를 이용하고자 하였다. 따라서 객체지향 디자인패턴 5원칙의 단일책임원칙을 응용하여 **도메인별로 각자 목적과 역할에 따라 폴더를 나누는 구조로 설계**하였다. 이를 통해 도메인 별로 **주제 관계성이 있는 컴포넌트 별로 응집도를 높일 수 있고 직관적**이어서 폴더를 쉽게 찾아 일의 효율을 높일 수 있었다. 공통적으로 사용하는 컴포넌트는 재사용성 및 중복 제거를 위해 componenet 폴더로 넣어 공통적으로 사용해주었다. 
<br />

(실제로 찾아보니 현실적으로 적용되기 어려운 이유들 때문에 atomic pattern으로 폴더 구조를 짠 사례가 거의 없었다. Atom design pattern은 개발을 위한 패턴 또는 컴포넌트를 나누기 위한 패턴이 아닌 컴포넌트 분리 구조에 대한 이해를 돕기위한 화학 용어를 차용한 디자인 모델이라고 한다.)

### 5.2. 메모이제이션 기준에 대한 고민
useMemo와 useCallback 사용의 기준에 대한 고민이 있었다. 이후 **재렌더링에 의한 재계산 및 함수 재선언의 비용**이 **렌더링 여부 결정을 위한 의존성 배열의 요소 비교 비용**과 큰 차이가 없는 것을 확인하였다. 이에 useCallback의 경우, **상위 컴포넌트의 props 변화로 인한 하위 컴포넌트의 렌더링으로 하위 컴포넌트의 함수이 재선언 되는 것과 같은 예상치 못한 동작을 보완하고자 할 때 사용한다는 기준**을 세웠다. 

이 프로젝트에서는 내가 작성한 컴포넌트 state의 흐름으로 봤을 때 props로 넘겨주는 함수가 컴포넌트로 넘김 받는 props에 의존을 다 하고 있었다. 그렇기 때문에 굳이 useCallback을 걸어줄 필요가 없다고 판단하였다. 

### 5.3. 동적으로 객체의 값을 키 값으로 선택 [코드 예시](https://github.com/han-byul-yang/Google_Form_Clone/blob/4869b5b8545b65161198d089d35def7cae808f38/src/routes/Answer/AnswerOption/index.tsx#L23)
객체의 키 값을 이용해 구글 질문 폼의 옵션 컴포넌트를 **선언적이고, 동적으로 선택**하도록 하였다. 

### 5.4. key 값 id vs index
순서가 변경되는 등의 리스트의 경우에는 렌더링의 reconciliation을 고려하여 고유 id값을 key 값으로 제공해주었지만, 단순히 배열을 나열하는 경우에는 index 값으로 key 값을 대체해주었다. 
